# Base docker-compose for SERVER tests
#
# Pattern: test.py is a long-running server, client.py generates load
# Use with: docker compose -f docker-compose.server-base.yml -f tests/xxx/docker-compose.yml run --rm cleanup
#
# Required in test directory:
#   - test.py         : Server code (runs under retrace)
#   - client.py       : Load generator (infrastructure)
#   - requirements.txt: Server dependencies (optional)
#
# Environment variables:
#   - TEST_DIR: Path to test directory (e.g., ./tests/flask_test)
#   - TEST_IMAGE: Base image (default: python:3.11-slim)
#   - SERVER_PORT: Port server listens on (default: 5000)
#   - SERVER_HEALTH_PATH: Health check path (default: /health)

services:
  # Install dependencies
  install:
    image: ${TEST_IMAGE:-python:3.11-slim}
    volumes:
      - ./install.sh:/app/install.sh:ro
      - ./base-requirements.txt:/app/dockertests/base-requirements.txt:ro
      - ${TEST_DIR}:/app/test:ro
      - ./.cache/pip:/root/.cache/pip
      - ${TEST_PACKAGES_DIR:-./.cache/packages}:/app/packages
    command: bash /app/install.sh

  # Dryrun - server runs native, client generates load
  server-dryrun:
    image: ${TEST_IMAGE:-python:3.11-slim}
    depends_on:
      install:
        condition: service_completed_successfully
    volumes:
      - ${TEST_DIR}:/app/test:ro
      - ${TEST_PACKAGES_DIR:-./.cache/packages}:/app/packages:ro
    environment:
      PYTHONPATH: /app/packages
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:${SERVER_PORT:-5000}${SERVER_HEALTH_PATH:-/health}')"]
      interval: 2s
      retries: 10
      start_period: 3s
    command: python /app/test/test.py

  dryrun:
    image: ${TEST_IMAGE:-python:3.11-slim}
    depends_on:
      server-dryrun:
        condition: service_healthy
    volumes:
      - ${TEST_DIR}/client.py:/app/client.py:ro
    environment:
      SERVER_URL: http://server-dryrun:${SERVER_PORT:-5000}
    command: bash -c "pip install -q requests && python /app/client.py"

  # Record - server under retrace, client generates load
  server-record:
    image: ${TEST_IMAGE:-python:3.11-slim}
    depends_on:
      dryrun:
        condition: service_completed_successfully
    volumes:
      - ${TEST_DIR}:/app/test:ro
      - ${TEST_DIR}/recording:/recording:rw
      - ${TEST_PACKAGES_DIR:-./.cache/packages}:/app/packages:ro
    environment:
      PYTHONPATH: /app/packages
      RETRACE: "1"
      RETRACE_RECORDING_PATH: /recording
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:${SERVER_PORT:-5000}${SERVER_HEALTH_PATH:-/health}')"]
      interval: 2s
      retries: 10
      start_period: 5s
    command: bash -c "python -m retracesoftware install && python /app/test/test.py"

  record:
    image: ${TEST_IMAGE:-python:3.11-slim}
    depends_on:
      server-record:
        condition: service_healthy
    volumes:
      - ${TEST_DIR}/client.py:/app/client.py:ro
    environment:
      SERVER_URL: http://server-record:${SERVER_PORT:-5000}
    command: bash -c "pip install -q requests && python /app/client.py"

  # Replay - server replays from recording (no client needed)
  replay:
    image: ${TEST_IMAGE:-python:3.11-slim}
    depends_on:
      record:
        condition: service_completed_successfully
    network_mode: none
    volumes:
      - ${TEST_DIR}:/app/test:ro
      - ${TEST_DIR}/recording:/recording:ro
      - ${TEST_PACKAGES_DIR:-./.cache/packages}:/app/packages:ro
    environment:
      PYTHONPATH: /app/packages
    command: python -m retracesoftware --recording /recording

  # Cleanup
  cleanup:
    image: ${TEST_IMAGE:-python:3.11-slim}
    depends_on:
      replay:
        condition: service_completed_successfully
    volumes:
      - ${TEST_DIR}/recording:/recording:rw
    command: sh -c "rm -rf /recording/* && echo 'âœ“ Recording cleaned up'"

# No named volumes - using local .cache/ directory for packages
